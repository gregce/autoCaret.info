---
title: "Getting Started"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
---

```{r echo = FALSE}

knitr::opts_chunk$set(collapse = TRUE, comment = "#>")

# Use vertical split by default in this Rmd document
knit_print.htmlwidget <- function(x, ...) {
  # Get the chunk height
  height <- knitr::opts_current$get("height")
  if (length(height) > 0 && height != FALSE)
    x$height <- height
  else
    x$height <- "450px"

  htmlwidgets:::knit_print.htmlwidget(x, ...)
}
```


Currently, the `autoCaret` package is not hosted on CRAN, but can be obtained from GitHub. To do so, first make sure you have [devtools](https://cran.r-project.org/web/packages/devtools/index.html) installed.

``` {r, eval=FALSE}
install.packages("devtools")
```

To install the first _preview release_ of `autoCaret` from GitHub:

```{r eval=FALSE}
devtools::install_github("gregce/autoCaret")
```

Once the `autoCaret` package is installed, you may access its functionality as you would any other package by calling:

``` {r, eval=FALSE}
library("autoCaret")
```

Additionally, the RStudio IDE includes integrated support for using autoCaret as an add-in. These features are available in the current [Release of RStudio](https://www.rstudio.com/products/rstudio/download/).

## Using `autoModel`

We begin by loading the `mlbench` package and some example data `Sonar` which is commonly used to binary classification problems. In this example, we will attempt to distinguish Mines (M) from Rocks (R) using binary classification with an initial dataset of where N=208 and P=60.  

As a general rule, when using `autoCaret::autoModel` defaults, datasets less than 100 mb should yield optimal performance and likely avoid extremely long run times & high memory requirements. 

```{r, eval=TRUE}
library(mlbench)
library(autoCaret)

# Load the data into Memory from the mlbench package
data("Sonar")

# Summarize Sonar's Size
dim(Sonar)

# Check out Variable Names
names(Sonar)
```


Having both the data loaded and having inspected it, we can now make use of the `autoCaret::autoModel()` function In this example, we'd like to try and distinguish Rocks (R) from Mines (R), so we will attempt to predict the `Class` variable in the Sonar dataframe.

Using it's defaults, `autoModel` has 2 arguments we need to specify: `df` and `y`.

`df` is the Dataframe that we'd like to use build a binary classification model, while `y` is our classification target or response variable. We can use a non-exported package function, `autoCaret:::checkBinaryTrait` to determine if our `y` variable is indeed binary. The `autoModel` functionality will perform this for us as well.


```{r, eval=TRUE, cache=TRUE, warning=FALSE, message=FALSE}
# Manually check that our intended y paramter is indeed binary
autoCaret:::checkBinaryTrait(Sonar$Class)

# Generate an autoCaret object using the autoModel function
mod <- autoCaret::autoModel(df = Sonar, y = Class, progressBar = FALSE)
```

<br> 

## Exploring an `autoCaret` object

In the example above, the returned object, `mod`, is an `autoCaret` object containing 16 objects. To confirm, we can run the below two commmands:

```{r eval=TRUE, warning=FALSE, message=FALSE}
# Check class of autoCaret object
class(mod)

# High level 
nrow(summary.default(mod))
```

Running the summary function on our model output displays a wealth of information about the contents of the object as well as the procedural steps taken during modeling. In our example, we observe:

 - that our initial dataset of 208 observation was split into a training and test set containing 167 and 41 observations 
 - Modeling took .64 minutes and entailed resampling our dataset 10 times 
 - We used the four default models to create an ensemble.
 - Using the ensemble model that was generated to predict on the test set yield predictions with 92% accuracy. 

```{r eval=TRUE, warning=FALSE, message=FALSE}
# Use the summary generic to store a summary of autoCaret object
overview <- summary(mod)
```

We can also access each of the object variables included in the above displayed summary output via the object itself.

```{r eval=TRUE, warning=FALSE, message=FALSE}
# Print the overview to the console
overview
```

<br>

## Predicting new data

So now that we have a sense of how successful our auto modeling approach was, we'd likely want to use the model, `mod`, we built previously to make predictions on new data we receive. 

Because this is an illustrative example, we'lll take a shortcut by just resampling the same data that we used to train on. The main point here is that you can simply pass your `autoCaret` model object, `mod`, into the `predict()` function along with new observations to generate predictions. 

```{r eval=TRUE, warning=FALSE, message=FALSE}

#For the sake of example, simulate new data by resampling our original data frame
new <- Sonar[sample(1:nrow(Sonar), 50, replace=TRUE),]

#Make predicitons 
preds <- predict(mod, new)

#Print Predictions 
preds
```

How well did we do? Well a confusion matrix from the `caret` package can tell us!

- We only mispredicted one example, for overall accuracy of .98
- **Note:** we wouldn't expect this level of accuracy using real data given we resampled from our original training set. 

```{r eval=TRUE, warning=FALSE, message=FALSE}
## How well did we do?
caret::confusionMatrix(data = preds, reference = new$Class)
```
